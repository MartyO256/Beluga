include module type of Stdlib.Option

val eliminate : (unit -> 'b) -> ('a -> 'b) -> 'a option -> 'b

(** [get_default o default] is [v] if [o] is [Some v] and [default]
    otherwise. *)
val get_default : 'a -> 'a option -> 'a

(** Gets the value from an option if it exists. Otherwise raises the given
    exception. *)
val get' : exn -> 'a option -> 'a

(** [get_or_else f o] is [f ()] if [o] is [None] and [v] if [o] is [Some v]. *)
val get_or_else : (unit -> 'a) -> 'a option -> 'a

(** Convert a boolean to an option. When used with other monadic operations,
    this is (a specialized) `guard` function from Haskell, which allows to
    abort a monadic computation on account of a boolean check. *)
val of_bool : bool -> unit option

val ( $ ) : 'a option -> ('a -> 'b option) -> 'b option

(** Named, flipped version of ($). *)
val flat_map : ('a -> 'b option) -> 'a option -> 'b option

val lazy_alt : 'a option Lazy.t -> 'a option Lazy.t -> 'a option Lazy.t

(** Selects the first alternative that succeeds. Forces every thunk until one
    computes [Some x]. *)
val choice : 'a option Lazy.t list -> 'a option Lazy.t

(** Returns the first option that isn't None, if any. *)
val alt : 'a option -> 'a option -> 'a option

(** Maps a function that may fail over a list, and eagerly fails as soon as
    any individual call fails. Note that elements beyond the first failing
    one will not be processed. *)
val traverse : ('a -> 'b option) -> 'a list -> 'b list option

(** Maps a function that may fail over a list, and eagerly fails as soon as
    an individual call fails. The functions themselves may not compute
    interesting results. *)
val traverse_ : ('a -> unit option) -> 'a list -> unit option

(** Folds a list with a function that may fail, eagerly failing. Note that
    elements beyond the first failing one will not be processed. *)
val fold_left : ('b -> 'a -> 'b option) -> 'b -> 'a list -> 'b option

val void : 'a option -> unit option

(** Removes all [None] options from the list. In fact, [cat_options] is
    implemented in terms of {!List.filter_map}. *)
val cat_options : 'a option list -> 'a list

(** Specialized effectful eliminator for option types. *)
val when_some : 'a option -> ('a -> unit) -> unit

(** Specialized eliminator for options to print them generally. *)
val print' :
     (Format.formatter -> unit -> unit)
  -> (Format.formatter -> 'a -> unit)
  -> Format.formatter
  -> 'a option
  -> unit

(** Prints an option by doing nothing if it is [None]; else it uses the given
    printer. *)
val print :
  (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a option -> unit

(** Prints an option by showing ["None"] or ["Some X"] where ["X"] is
    generated by the given formatting function. *)
val show :
  (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a option -> unit

(** {1 Instances} *)

include Monad.MONAD with type 'a t := 'a t

include Functor.FUNCTOR with type 'a t := 'a t

include Apply.APPLY with type 'a t := 'a t

(** Functor for an instance of {!Eq.EQ} over option values. *)
module MakeEq (E : Eq.EQ) : Eq.EQ with type t = E.t t

(** Functor for an instance of {!Ord.ORD} over option values. [None] is
    consided to be less than any [Some v] value. *)
module MakeOrd (O : Ord.ORD) : Ord.ORD with type t = O.t t
